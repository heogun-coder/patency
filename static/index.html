<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>암호화 웹서버</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { margin: 10px; padding: 10px; }
        input, textarea { margin: 10px; padding: 5px; }
    </style>
</head>
<body>
    <h1>암호화 웹서버</h1>
    <button onclick="keyExchange()">키 교환</button>
    <h2>메시지 전송</h2>
    <input type="text" id="message" placeholder="메시지를 입력하세요">
    <button onclick="sendMessage()">Send</button>
    <h2>메시지 수신</h2>
    <button onclick="getMessage()">Get</button>
    <h3>수신된 메시지:</h3>
    <textarea id="received" rows="4" cols="50" readonly></textarea>

    <script>
        const SIZE = 8;
        const KEY_LIFETIME_MS = 5 * 60 * 1000;
        let M_A = null;
        let inv_M_A = null;
        let A = null;
        let TK = null;
        let averageRTT = null;
        let lastKeyExchangeTime = 0;

        function generateMatrix(size) {
            let matrix = [];
            for (let i = 0; i < size; i++) {
                let row = [];
                for (let j = 0; j < size; j++) {
                    row.push(Math.floor(Math.random() * 256));
                }
                matrix.push(row);
            }
            return matrix;
        }

        function tkToA(TK) {
            let A = [];
            for (let i = 0; i < SIZE; i++) {
                let row = [];
                for (let j = 0; j < SIZE; j++) {
                    let byte = parseInt(TK.substr(i*SIZE + j*2, 2), 16);
                    row.push(byte);
                }
                A.push(row);
            }
            return A;
        }

        function matrixAdd(A, B) {
            return A.map((row, i) => row.map((val, j) => val + B[i][j]));
        }

        function matrixSub(A, B) {
            return A.map((row, i) => row.map((val, j) => val - B[i][j]));
        }

        async function getAverageRTT() {
            const numPings = 3;
            let totalRTT = 0;
            for (let i = 0; i < numPings; i++) {
                const start = Date.now();
                const response = await fetch('/ping');
                const data = await response.json();
                const end = Date.now();
                const RTT = end - start;
                totalRTT += RTT;
            }
            return Math.round(totalRTT / numPings);
        }

        async function computeTK(averageRTT) {
            const encoder = new TextEncoder();
            const data = encoder.encode(String(averageRTT));
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function keyExchange() {
            averageRTT = await getAverageRTT();
            TK = await computeTK(averageRTT);
            A = tkToA(TK);
            M_A = generateMatrix(SIZE);
            inv_M_A = numeric.inv(M_A);
            const M_prime_A = matrixAdd(M_A, A);
            const response = await fetch('/key_exchange', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ "average_RTT": averageRTT, "M_prime_A": M_prime_A })
            });
            const data = await response.json();
            const M_prime_B = data.M_prime_B;
            const M_B = matrixSub(M_prime_B, A);
            lastKeyExchangeTime = Date.now();
            alert("키 교환 성공");
            setTimeout(() => {
                alert("키 수명이 만료되었습니다. 키 교환을 다시 수행하세요.");
            }, KEY_LIFETIME_MS);
        }

        function prepareMessage(message) {
            const blockSize = SIZE;
            let blocks = [];
            for (let i = 0; i < message.length; i += blockSize) {
                let block = message.slice(i, i + blockSize);
                while (block.length < blockSize) {
                    block += '\0';
                }
                blocks.push(block.split('').map(c => c.charCodeAt(0)));
            }
            return blocks;
        }

        function encrypt(message) {
            const blocks = prepareMessage(message);
            const encrypted = blocks.map(block => numeric.dot(block, M_A));
            return encrypted;
        }

        function decrypt(encrypted) {
            const decryptedBlocks = encrypted.map(C => {
                const M_approx = numeric.dot(C, inv_M_A);
                return M_approx.map(x => Math.round(x));
            });
            return decryptedBlocks.map(block => block.map(code => String.fromCharCode(code)).join('')).join('').replace(/\0+$/, '');
        }

        async function sendMessage() {
            if (!M_A || Date.now() - lastKeyExchangeTime > KEY_LIFETIME_MS) {
                alert("키가 만료되었거나 설정되지 않았습니다. 키 교환을 수행하세요.");
                await keyExchange();
                if (!M_A) return;
            }
            const message = document.getElementById('message').value;
            if (!message) {
                alert("메시지를 입력하세요");
                return;
            }
            const encrypted = encrypt(message);
            const response = await fetch('/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ "encrypted": encrypted })
            });
            const result = await response.json();
            alert(result.status === 'success' ? '메시지 전송 성공!' : '전송 실패');
        }

        async function getMessage() {
            if (!M_A || Date.now() - lastKeyExchangeTime > KEY_LIFETIME_MS) {
                alert("키가 만료되었거나 설정되지 않았습니다. 키 교환을 수행하세요.");
                await keyExchange();
                if (!M_A) return;
            }
            const response = await fetch('/get');
            const result = await response.json();
            if (result.status === 'no messages') {
                document.getElementById('received').value = '저장된 메시지가 없습니다.';
            } else {
                const decrypted = decrypt(result.encrypted);
                document.getElementById('received').value = decrypted;
            }
        }

        window.onload = keyExchange;
    </script>
</body>
</html>